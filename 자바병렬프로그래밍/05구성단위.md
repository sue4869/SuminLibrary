# 05. 구성 단위

### 5.1 동기화된 컬렉션 클래스 : Vector , HashTable

- 락, 동기화 기법 사용 없이 스레드 안정성 확보함
- public으로 선언된 모든 메소드를 클래스 내부에 캡슐하해 내부의 값을 한번에 한 스레드만 사용할 수 있도록 제어
- 동기화된 컬렉션 클래스의 문제점
    - 예를 들어, vector 내부의 값을 여러 스레드에서 마구 변경하는 상황에서 반복기능을 사용한다면 문제 발생
        
        → vector 내부의 데이터는 예외 상황이 발생하는 것과 무관하게 스레드 안전한 상태, 예외는 단지 설계 방향에 의해 발생시키는 것일 뿐
        
        → 반복문을 실행하는 동한 동기화시키기 위해 락을 사용한다면? (synchronized) 
        
        내부 값을 변경하는 모든 스레드 대기 상태로 → 병렬 프로그램 X
        
        - 반복문에서 락을 잡고 있는 상태에서 다른 락을 확보해야 한다면 데드락 발생 가능성 존재
        - 락을 거는 대신, clone메소드로 복사본을 만들어 복사본을 대상으로 사용.
- Iterator, ConcurrentModificationException
    
    Iterator : 다른  스레드가 같은 시점에 컬렉션 클래스 내부의 값을 변경하는 작업 처리시 ConcurrentModificationException 발생(즉시 멈춤)
    
    toString, hashCode, equals 등이 내부적으로 iterator 사용한다.
    

### 5.2 병렬 컬렉션

HashMap → ConcurrentHashMap

Queue → BlockingQueue

- Queue : 동기화를 맞추느라 대기상태에서 기다리는 부분 없음.
- BlockingQueue :  큐에 항목을 추가하거나 뽑아내는 상황에 따라 대기할 수 있도록 구현됨. 큐가 가득차있으면 새로운 항목을 추추하는 연산은 큐에 빈자리가 생길때까지 대기. procuder-consumer 패턴 구현시 사용

List → CopyOnWriteArrayList

SortedMap → ConcurrentSkipListMap

SortedSet → ConcurrentSkopListSet

- ConcurrentHashMap
    - 락스트라이핑(lock striping)을 사용하여 여러 스레드에서 공유하는 상태 가능
    - 값 읽어가는 연산, 읽기 연산, 쓰기 연산도 동시에 처리가능
    - ConcurrentHashMap의 Iterator는 ConcurrentModificationException 발생 안함.
        
        → 미약한 일관성 전략 
        
    - 동기화된 Map과 달리 ConcurrentHashMap에서는 맵을 독점적으로 사용할 수 있도록 락을 잡아 다른 스레드에서 사용하지 못하게 하는 기능 없음
    
- CopyOnWriteArrayList
    - 불변객체를 외부에 공개하면 여러 스레드가 동시에 사용하려는 환경에서도 별다른 동기화 작업이 필요없다는 개념으로 스레드 안정성 확보
    - 컬렉션의 내용이 변경될 때마다 복사본을 새로 만들어 내는 전략 취함.
        - 동시 사용성 문제 없게 함
        - 복사본을 만들어내기 때문에 성능에 손해. 컬렉션에 많은 자료가 있으면 안됨
        - 변경작업보다는 조회하는 것이 빈번한 경우 사용 ex) 이벤트 리스너를 관리하는 부분

### 5.3 블로킹 큐와 프로듀서-컨슈머 패턴

프로듀서 - 컨슈머 패턴

- 해야할일 목록을 두고 작업을 생성하는 주체와 처리하는 주체를 분리시키는 설계 방법
- Executor내부에서 해당 패턴 사용
- 프로듀서 - 컨슈머 패턴의 장점
    - 서로 독립적으로 실행됨.
    - 순차적으로 실행하는 것보다 성능이 높아짐
- 블로킹 큐를 사용하면 여러개의 프로듀서와 여러개의 컨슈머가 작동하는 패턴 구현 가능
    - 블로킹 큐 : 처리할 수 있는 양보다 훨씬 많은 작업이 생겨 부하가 걸리는 상황에서 작업량을 조절해 애플리케이션이 안정적으로 동작하도록 유도할 수 있다.
    - 종류
        
        LinkedList → LinkedBlockingQueue
        
        ArrayList →  ArraayBlockingQueue
        
        priorityQueue → ProrityBlockingQueue
        
        SynchronousQueue 
        
        - 프로듀서와 컨슈머가 직접 데이터를 주고 받을때까지 대기
        - 데이터 쌓아둘 공간 없음
        - 데이터를 넘겨 방들 수 있는 충분한 개수의 컨슈머가 대기하고 있는 경우에 사용
- 가변객체를 사용할때 객체의 소유권을 프로듀에서 컨슈머로 넘기는 과정에서 **직렬 스레드 한정 기법** 사용
    - 객체에 대한 소유권을 이전하여 컨슈머 스레드가 객체에 대한 유일한 소유권을 가지고, 프로듀서 스레드는 이전된 객체에 대한 소유권 완전히 잃는다.
    - 항상 소유권을 이전받는 스레드는 하나여야 한다.
    - 사용 예시 : 객체 풀
    
- 작업 가로 채기
    - 모든 컨슈머가 각자의 덱을 가진다.
    - 특정 컨슈머가 자신의 덱에 들어 있던 작업을 모두 처리시 다른 컨슈머의 덱의 맨 뒤의 작업을 가로채 가져올 수 있음.
    - 컨슈머가 프로듀서의 역할도 갖고 있는 경우에 적용하기 좋음.

### 5.4 블로킹 메소드, 인터럽터블 메소드

블로킹 연산 :  멈춘 상태에서 특정한 신호를 받아야 계속해서 실행할 수 있는 연산

블로킹 메소드 : InterruptedException(ex. Thread.sleep() )을 발생시킬 수 있는 메소드 

### 5.5 동기화 클래스(synchronizer)

상태 정보를 사용해 스레드 간의 작업 흐름을 조절할 수 있도록 만들어진 모든 클래스

- 래치
    - 스스로가 터미널 상태에 이를 때까지의 스레드가 동작하는 과정을 늦출 수 있도록 해주는 동기화 클래스
    - 특정한 단일 동작이 완료되기 이전에는 어떤 기능도 동작하지 않도록 막아내야 하는 경우 사용
    - 일회성 객체 - 한번 터미널 상태에 다다르면 이전 상태로 회복 불가
- futureTask
    - 래치와 동작방식 같음
    - Executor 에서 비동기적인 작업을 실행할 때 사용
    - 시간이 많이 필요한 모든 작업이 있을 때 실제 결과가 필요한 시점 이전에 미리 작업을 실행시켜두는 용도로 사용 → 실제로 결과를 필요로 하는 시점이 됐을때 대기시간 줄일 수 있음
- 세마포어 ( 카운팅 세마포어)
    - 특정 자원이나 특정 연산을 동시에 사용하거나 호출할 수 있는 스레드의수를 제한하고자 할때 사용
    - 자원 풀(pool) 이나 컬렉션의 크기에 제한을 두고자 할때 유용
    - 가상의 퍼밋을 만들어 내부 상태 관리 (퍼밋 : 세마포어 속 동시에 접근 가능한 스레드 수)
- 배리어
    - 특정 이벤트가 발생할 때까지 여러개의 스레드를 대기 상태로 잡아둔다 → 래치와 비슷
    - 모든 스레드가 배리어 위치에 동시에 이르러야 관문이 열리고 계속세서 실행할 수 있다.
        - 래치 : ‘이벤드’를 기다리기 위한 동기화 클래스
        - 배리어 : ‘다른 스레드’를 기다리기 위한 동기화 클래스